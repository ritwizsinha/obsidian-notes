### Components
- Text Section
- Program Counter
- Stack (Function Params, Return Addresses, Local Variables)
- Data Section (Global Variables)
- Heap (Dynamically allocated memory)
- Stack goes down heap comes up

#### States
New, Running, Waiting, Ready, Terminated


## **Interrupt Servicing - Notes**

### **1. What is an Interrupt?**

An **interrupt** is a signal that temporarily halts CPU execution to handle urgent tasks.

#### **Types**

- **Hardware** – From external devices (keyboard, timer, etc.).
    - **Maskable (IRQ)** – Can be disabled.
    - **Non-Maskable (NMI)** – Cannot be disabled.
- **Software** – Generated by software (system calls, exceptions).

---

### **2. Servicing Steps**

1. **Interrupt Occurs** – A device or software triggers an interrupt.
2. **CPU Acknowledges & Disables Further Interrupts** – Prevents re-entry.
3. **Identify Source** – Uses the **Interrupt Vector Table (IVT)**.
4. **Save Context** – Registers and program state are stored.
5. **Execute ISR** – Interrupt Service Routine handles the interrupt.
6. **Restore Context** – Saved registers are reloaded.
7. **Re-enable Interrupts & Resume** – Normal processing resumes.

---

### **3. Example: Keyboard Interrupt**

8. User presses a key → Keyboard sends an interrupt.
9. CPU pauses execution and looks up the ISR.
10. ISR reads key data and processes it.
11. CPU restores state and resumes execution.

---

### **4. Handling Mechanisms**

- **Priority Handling** – Higher-priority interrupts are handled first.
- **Nested Interrupts** – Higher-priority interrupts can interrupt an ISR.
- **Interrupt Masking** – Temporary blocking of interrupts during critical operations.
- **Interrupt-Driven I/O** – Devices notify the CPU instead of constant polling.

---

### **5. Role of OS**

- Manages **Interrupt Descriptor Table (IDT)**.
- Ensures **safe execution** of system-level instructions.
- Efficient **process scheduling** for smooth multitasking.



#### Overwhelming Interrupts
Yes, network traffic **does trigger interrupts**, but optimizations like **interrupt coalescing, polling (NAPI), DMA, and offloading** help reduce CPU overhead and improve performance.


### **Process Control Block (PCB)**

The **Process Control Block (PCB)** is a data structure used by the operating system to store information about a process. It helps the OS manage process execution efficiently.

### **Data Stored in PCB**

1. **Process ID (PID):** Unique identifier for the process.
2. **Process State:** Running, Ready, Waiting, etc.
3. **CPU Registers:** Stores register values during context switching.
4. **Program Counter (PC):** Address of the next instruction.
5. **Memory Management Info:** Base & limit registers, page tables.
6. **I/O Status:** Open files, devices assigned.
7. **CPU Scheduling Info:** Priority, scheduling queue info.

The PCB is crucial for multitasking, as it allows the OS to switch between processes efficiently.


### Storage of all PCBS
In a doubly linked list with Red Black tree on pids for effecient finds.


### Process Scheduling
The scheduler has queues of its own
1. IO Wait queue
2. Child Termination Wait Queue
3. Interrupt Wait queue
4. Ready Queue

The interrupt queue is only for processses waiting for an I/O event .
Daemons and server processes are not placed in wait queue as those constructs are more for a higher software level.

All of the state is saved from the Memory structures to the PCB in the kernel memory space.

#### Constructs in Processes
1. fork : Creating a new process with same memory space.
2. exec: Change the memory space.
3. exit: Remove from os
4. wait: return status data from child to parent.
5. abort: abort a child

#### Terminating processes.
1. Zombie: A child process which has terminated but has an entry in the process table because the parent has not collected its status. No CPU usage just an entry in page table.
2. Orphan: Parent terminated without collecting info.


### IPC
- Shared Memory
- Message Passing

#### Message Passing
Unbounded buffer: Consumer overwhelmed
Bounded buffer: messages missed.

Procesess communicating over a port are communicating using message passing.


#### Pipes
1. Unnamed pipes: Communication is unidirectional is only limited to the child and parent
2. Named Pipes: Bidirectional and between different processes.

#### Client server systems
1. Sockets: IP + Port
2. RPC

#### Socket types
1. TCP Connection Oriented
2. Connectionless UDP
3. Multicast socket.
A single socket can only be associated with one at a time.

RPCs are not exactly once deliverable.



